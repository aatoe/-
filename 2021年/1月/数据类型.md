# 数据类型

#### 基本数据类型

> 存储在栈内存 

Number

String

Boolean

Null

undefined

#### 引用数据类型「复杂数据类型」

> 存储在堆内存 

Object

- Array 
- RegExp
- Date
- Math
- Function

#### 特殊数据类型

Symbol

BigInt



#### 数据类型检测

```js
第一种 typeof
	typeof 1 // 'number'
	typeof '1' // 'string'
	typeof undefined // 'undefined'
	typeof true // 'boolean'
	typeof Symbol() // 'symbol'
	typeof null // 'object' ===> null 是基本数据类型按道理是null，但是因为null 是JavaScript的bug，不能作为			判断null的方法 可以使用 xx === null 即可。
	typeof [] // 'object'
	typeof {} // 'object'
	typeof console // 'object'
	typeof console.log // 'function'
	
	
第二种、instanceof：判断这个对象是否是之前那个构造函数生成的对象
	let Car = function(){}
	let benz = new Car()
	benz instanceof Car // true
	let car = new String("benz")
	car instanceof String // true
	let str = 'hello word'
	str instanceof String // false

原生实现 instanceof
function myInstanceof(left, right) {
  // 这里先用typeof来判断基础数据类型，如果是，直接返回false
  if (typeof left !== 'object' || left === null) return false
  // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
  let proto = Object.getPrototypeOf(left)
  while (true) {
    //循环往下寻找，直到找到相同的原型对象
    if (proto === null) return false
    if (proto === right.prototype) return true //找到相同原型对象，返回true
    proto = Object.getPrototypeof(proto)
  }
}
// 验证一下自己实现的myInstanceof是否OK
 console.log(myInstanceof(benz, Car));
console.log(myInstanceof(new Number(123), Number)) // true
console.log(myInstanceof(123, Number)) // false

1、instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；
2、而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。

总之，不管单独用 typeof 还是 instanceof，都不能满足所有场景的需求，而只能通过二者混写的方式来判断。但是这种方式判断出来的其实也只是大多数情况，并且写起来也比较难受，你也可以试着写一下。

第三种、Object.prototype.toString
toString() 是 Object 的原型方法。
每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。
由于默认方法toString 是不接受参数的，所以需要Object.prototype.toString.call(xx)这种格式来调用
如果不使用 Object.prototype.toString(xx)。无论传什么都是返回 "[object Object]"

console.log(Object.prototype.toString.call({})); // "[object Object]"
console.log(Object.prototype.toString.call(1)); // "[object Number]"
console.log(Object.prototype.toString.call("1")); // "[object String]"
console.log(Object.prototype.toString.call(true)); // "[object Boolean]"
console.log(Object.prototype.toString.call(function() {})); // "[object Function]"
console.log(Object.prototype.toString.call(null)); //"[object Null]"
console.log(Object.prototype.toString.call(undefined)); //"[object Undefined]"
console.log(Object.prototype.toString.call(/123/g)); //"[object RegExp]"
console.log(Object.prototype.toString.call(new Date())); //"[object Date]"
console.log(Object.prototype.toString.call([])); //"[object Array]"
console.log(Object.prototype.toString.call(document)); //"[object HTMLDocument]"
console.log(Object.prototype.toString.call(window)); //"[object Window]"

总结：Object.prototype.toString 能把所有类型都能检测出来，所以推荐使用这种方式
```

