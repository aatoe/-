# 双向数据绑定

**双向数据绑定就是 页面 和 数据 无论哪一方发生改变，都可以改变当前的数据。**

#### 脏检查

> 说的是以前老版本的 Angularjs
>
> Angularjs内部会维护一个序列，将所有需要监控的属性放在这个序列中，当发生某些特定事件时（注意，这里并不是定时的而是由某些特殊事件触发的），Angularjs会调用 $digest 方法，这个方法内部做的逻辑就是遍历所有的watcher），对被监控的属性做对比，对比其在方法调用前后属性值有没有发生变化，如果发生变化，则调用对应的handler。

#### 观察机制（Object.observe()）

> 下面这一段来自MDN https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
>
> **已废弃**
> This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.
>
> **`Object.observe()`** 方法用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。然而，这个接口已经被废弃并从各浏览器中移除。你可以使用更通用的 [`Proxy`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 对象替代。

#### 封装属性访问器

> vue.js实现数据双向绑定的原理就是属性访问器
>
> 使用了Object.defineProperty 方法，现在的vue3.0已经使用了 Proxy





####  体验Object.defineProperty 

如果不了解Object.defineProperty [传送门](https://github.com/aatoe/technical-article/blob/master/2020%E5%B9%B4/6%E6%9C%88/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.md)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input type="text" id="input" />
    <p id="data"></p>
  </body>
  <script>
    const obj = {}
    // 获取 input标签原生dom
    const input = document.getElementById('input')
    // 数据劫持。
    // 当 obj.name 时必须触发get()才会返回出来。
    // 当 obj.name = "xx" 时，这里是 obj.name = input.value ，触发了set 进而将data中的值也赋值了。
    Object.defineProperty(obj, 'name', {
      configurable: true,
      enumerable: true,
      get() {
        console.log(`obj.name 也就是获取值时触发`);
        return input.value
      },
      set(newVal) {
        console.log(`obj.name='xx' 也就是设置值时触发`);
        input.value = newVal
        document.getElementById('data').innerHTML = newVal
      },
    })
    // 监听输入框，实现视图->数据的绑定
    input.addEventListener('keyup', () => {
      obj.name = input.value
    })

    // 这个domo是有问题了，get是无法触发，只有set触发了，只是一个deomo而已。
    // 后面的代码，get() 将是至关重要
  </script>
</html>

```



![简易版](/Users/atoe/Desktop/blog/-/static/images/简易版.png)

#### 完整版

如果不了解类，[传送门](https://github.com/aatoe/technical-article/blob/master/2019%E5%B9%B4/11%E6%9C%88/%E7%B1%BBclass.md)

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title></title>
  </head>

  <body>
    <div id="app">
      <div>
        <input v-model="value" />
        <p v-text="value"></p>
      </div>
    </div>
  </body>

  <script>
    // 收集依赖
    class Dep {
      constructor() {
        this.subs = []
      }

      addSub(sub) {
        this.subs.push(sub)
      }

      removeSub(sub) {
        remove(this.subs, sub)
      }

      depend() {
        if (window.target) {
          this.addSub(window.target)
        }
      }

      notify() {
        const subs = this.subs.slice()
        for (let i = 0, l = subs.length; i < l; i++) {
          subs[i].update()
        }
      }
    }

    // 使数据变成setter getter
    /**
     * Observer类会附加到每一个被侦测的object上。
     * 一旦被附加上，Observer会将object的所有属性转换为getter/setter的形式
     * 来收集属性的依赖，并且当属性发生变化时会通知这些依赖
     */
    class Observer {
      constructor(value) {
        this.value = value

        if (!Array.isArray(value)) {
          this.walk(value)
        }
      }

      /**
       * walk会将每一个属性都转换成getter/setter的形式来侦测变化
       * 这个方法只有在数据类型为Object时被调用
       */
      walk(obj) {
        const keys = Object.keys(obj)
        for (let i = 0; i < keys.length; i++) {
          defineReactive(obj, keys[i], obj[keys[i]])
        }
      }
    }

    function defineReactive(data, key, val) {
      // 新增，递归子属性
      if (typeof val === 'object') {
        new Observer(val)
      }
      let dep = new Dep()
      Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
          console.log('触发了get' + val)
          dep.depend()
          return val
        },
        set: function (newVal) {
          console.log('触发了set' + newVal)
          if (val === newVal) {
            return
          }
          val = newVal
          dep.notify()
        },
      })
    }

    class Watcher {
      constructor(vm, node, name) {
        this.vm = vm
        this.node = node
        this.name = name
        this.value = this.update()
      }

      get() {
        window.target = this
        // 收集依赖,触发get，
        let value = this.vm.data[this.name]
        window.target = undefined
        return value
      }

      update() {
        this.value = this.get()
        this.node.innerText = this.value
      }
    }

    // 模板解析
    function Compile(el, vue, data) {
      // 关联自定义特性
      if (el.attributes) {
        // [].forEach.call(this,()=>{}) ==> Array.prototype.forEach(()=>{})
        // 为什么不直接使用 el.attributes.forEach(()=>{}) , 因为这是dom结构不支持，使用原生for循环可以，但是采用下面方案比较
        ;[].forEach.call(el.attributes, (attribute) => {
          if (attribute.name.includes('v-')) {
            Update[attribute.name](el, vue, data, attribute.value)
          }
        })
      }

      // 递归解析所有DOM
      ;[].forEach.call(el.childNodes, (child) => Compile(child, vue, data))
    }

    // 自定义特性对应的事件
    const Update = {
      'v-text'(el, vue, data, key) {
        // 初始化DOM内容
        el.innerText = data[key]
        // 收集依赖
        new Watcher(vue, el, key) 
      },
      'v-model'(input, vue, data, key) {
        // 收集依赖
        new Watcher(vue, input, key)
        // 初始化Input默认值
        input.value = data[key]
        // 监听控件的输入事件，并更新数据
        input.addEventListener('keyup', (e) => {
          vue.data[key] = e.target.value
        })
      },
    }

    function Vue(options) {
      this.data = options.data
      new Observer(this.data)
      let el = document.getElementById(options.el)
      let vue = this
      Compile(el, vue, this.data)
    }

    let vm = new Vue({
      el: 'app',
      data: {
        value: 'juice',
      },
    })
  </script>
</html>

```

![完整版](/Users/atoe/Desktop/blog/-/static/images/完整版.png)



总结： 其实上面两个例子只是体验一下双向数据绑定原理到底是怎么样的，我看见现在任何一篇文章不会写的特别特别详细，因为做不到啊，源码在vue里面，原理也是基于这个。