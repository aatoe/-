# 生成器

## 为什么会有生成器

```
它能帮我们解决什么样的问题，可以解决异步代码耗时操作，然后处理完成再继续操作（暂停），不会影响主程序。
好好利用起来 Promise + Generator 才是最后面解决问题的核心。
```

### Generator(生成器)

> Generator函数和普通的函数区别有两个。
>
>  1：function和函数名**之间有一个\*号**
>
>  2：函数体内部使用了**yield表达式**

这个玩意儿如果运行的话，会返回一个Iterator实例， 然后再执行Iterator实例的**next()**方法， 那么这个函数才开始真正运行， 并把yield后面的值**包装成固定对象并返回**，直到运行到函数结尾， 最后再返回**undefined**；  

Generator函数返回的Iterator运行的过程中，如果碰到了yield， 就会把yield后面的值返回， 此时函数相当于停止了， 下次再执行next()方法的时候， 函数又会从上次退出去的地方重新开始执行； 如果后面有return 返回值=yield+return中的返回值 后面的yield不会生效,不能在非Generator函数中使用yield 

```js
Generator函数返回的Iterator执行next()方法以后， 返回值的结构为 
{
    value : "value", //value为返回的值
    done : false //done的值为一个布尔值， 如果Interator未遍历完毕， 他会返回false， 否则返回true；
}

function *gen() {
  let x = 1;
  x++;
    yield "1";
    yield "2"
}
var it = gen(); // 生成一个迭代器（Iterator实例），此时没有启动。
console.log(it);  // "Generator {  }"
console.log(it.next().value);   // 启动迭代器 执行迭代器 执行let x = 1; x++ 将yield返回出来 1 ,运行到下一个yield暂停，it.next() 调用结束,此时 *gen() 仍在运行并且是活跃的，但处于暂停状态。
console.log(it.next().value);   // 调用从暂停处恢复了生成器 *gen() 的执行 执行迭代器 将yield返回出来 2 ，运行到下一个yield暂停，如果没有yield就迭代器运行结束。
console.log(it.next().value); // 当前已经没有yield了  undefined

生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。

传参数的生成器
function* gen(x) {
  x++;
  x = x * (yield "1");
  // x = x * (yield); // 将会返回undefined
  return x;
}
var it = gen(1); // 生成一个迭代器，此时没有启动，将 1 传进去。
console.log(it.next()); // 启动生成器 运行代码 x++，运行到yield 把 1，返回出去。
console.log(it.next(2)); // 4

// 1.可以看出来，x像普通函数传进去正常接收
// 2.当在迭代器中传值可以在yield中接收，然后恢复代码执行。
// 3.yield 返回值出来 
// 4.return 在最后一个yield后面返回值出来。

```

### 在看一些例子

```js
function* foo(x) {
	var y = 2 * (yield(x + 1)); 
	var z = yield(y / 3); 
	return (x + y + z); 
}

var a = foo(5);
console.log(a.next()) // x + 1 ===> 5+1 ===> 6
console.log(a.next()) // 没有参数传进去，yield接收到就是undefined y=  2 * undefined ===> NaN, NaN/3===>NaN。
console.log(a.next()) // 6 + NaN + undefined === NaN

var b = foo(5);
console.log(b.next()) // { value:6, done:false } 同上
console.log(b.next(12)) // { value:8, done:false } 当我们的next有参数就可以当做上一次yield的值,2*12/3=8
console.log(b.next(13)) // { value:42, done:true } 5+24+13 = 42
```

### 生成器委托

> yield*这种语句让我们可以在Generator函数里面再套一个Generator。
>
> 你要在一个Generator里面调用另外的Generator需要使用: **yield\* 函数()** 

```js
function* foo() {
   console.log("*foo() starting");
   yield 3;
   yield 4;
   console.log("*foo() finished");
 }
 function* bar() {
   yield 1;
   yield 2;
   yield* foo();
   yield 5;
 }
 var it = bar();
 console.log(it.next().value);
 console.log(it.next().value);
 console.log(it.next().value);
 console.log(it.next().value);
 console.log(it.next().value);

// 1
// 2
// *foo() starting
// 3
// 4
// *foo() finished

// 调用foo()创建一个迭代器。然后yield *把迭代器
// 实例控制(当前 *bar() 生成器的)委托给 / 转移到了这另一个 *foo() 迭代器。
```

## 生成器 +Promise（终极目标）

```js
function foo(x, y) {
  return new Promise((resolve, reject) => {
    resolve("成功了" + x + y);
  });
}
function* main() {
  try {
    var text = yield foo(11, 31);
    console.log(text);
  } catch (err) {
    console.error(err);
  }
}
let it = main();
let p = it.next().value; // 得到promise
p.then((res) => {
  console.log(res, "res");
});
```

